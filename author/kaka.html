<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Kaka Blog <small>kaka</small></title>
	<meta name="description" content="Coding, scientific development, finance, data analysis, visualization, statistics, and machine learning">
	<meta name="author" content="kaka">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
	<!--[if lt IE 9]>
		<script src="../theme/html5.js"></script>
		<![endif]-->
	<link href="../theme/css/ipython.css" rel="stylesheet">
	<link href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css" rel="stylesheet">
	<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">
	<link href="//maxcdn.bootstrapcdn.com/bootswatch/3.2.0/simplex/bootstrap.min.css" rel="stylesheet">
	<link href="../theme/css/local.css" rel="stylesheet">
	<link href="../theme/css/pygments.css" rel="stylesheet">
</head>
<body>
<div class="container">
	<div class="page-header">
		<h1><a href="../">Kaka Blog</a>
			<br>	</div>
	<div class="row">
		<div class="col-md-8 col-md-offset-2">
        
        
<div class="article" itemscope itemtype="http://schema.org/BlogPosting">
	<a href="../20_describe.html">
		<h2 itemprop="name headline">20 属性描述符</h2>
	</a>
	<time datetime="2017-09-14T00:37:00+02:00" itemprop="datePublished">Thu 14 September 2017</time>
	&nbsp;—&nbsp;
	<span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
		<span itemprop="name">kaka</span>
	</span>
	<div class="summary">
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>我们上一章使用特性工厂函数编程模式避免重复写读值和设值方法，这里继续，把 quantity 特性工厂函数重构为 Quantity 描述符类</p>
<h3 id="LineItem-类第三版：一个简单的描述符">LineItem 类第三版：一个简单的描述符<a class="anchor-link" href="#LineItem-类第三版：一个简单的描述符">¶</a></h3><p>实现了 <code>__get__</code>, <code>__set__</code> 或 <code>__delete__</code> 方法的类是描述符。描述符的用法是，创建一个实例，作为另一个类的属性</p>
<p>我们将定义一个 Quantity 描述符，LineItem 会用到两个 Quantity 实例，一个管理 weight 属性，一个管理 price 属性。</p>
<p>Quantity 实例是 LineItem 类的属性。</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input"></div>
	Category:
	<span itemprop="articleSection">
		<a href="../category/fluent_python.html" rel="category">fluent_python</a>
	</span>
	Tags:
 
	<span itemprop="keywords">
		<a href="../tag/describe.html" rel="tag">describe</a>
	</span>
</div>
<hr>
        
<div class="article" itemscope itemtype="http://schema.org/BlogPosting">
	<a href="../19_attr.html">
		<h2 itemprop="name headline">19 动态属性和特性</h2>
	</a>
	<time datetime="2017-09-13T00:40:00+02:00" itemprop="datePublished">Wed 13 September 2017</time>
	&nbsp;—&nbsp;
	<span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
		<span itemprop="name">kaka</span>
	</span>
	<div class="summary">
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Python 中，数据的属性和处理数据的方法统称属性（attribute）。其实，方法只是可调用的属性。除了这二者之外，我们还可以创建特性（property），在不改变类接口的前提下，使用存取方法（即读值方法和设值方法）修改数据属性。</p>
<p>除了特性，Python 还提供了丰富的 API，用于控制属性的访问权限，以及实现动态属性。使用点号访问属性时，Python 会调用特殊的方法（如 <code>__getattr__</code> 和 <code>__setattr__</code>）计算属性。用户自定义的类可以通过 <code>__getattr__</code> 方法实现 “虚拟属性”，当访问不存在的属性时，即时计算属性值</p>
<p>动态创建属性是一种元变成，框架作者经常这么做，在 Python 中，这种技术很简单，任何人都可以使用，甚至在日常数据转换任务都能用到</p>
<h2 id="使用动态属性转换数据">使用动态属性转换数据<a class="anchor-link" href="#使用动态属性转换数据">¶</a></h2><p>我们编写个脚本下载 OSCON 数据源，这是一份 JSON 数据，我们后面来解析它：</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input"></div>
	Category:
	<span itemprop="articleSection">
		<a href="../category/fluent_python.html" rel="category">fluent_python</a>
	</span>
	Tags:
 
	<span itemprop="keywords">
		<a href="../tag/__dict__.html" rel="tag">__dict__</a>
	</span>
</div>
<hr>
        
<div class="article" itemscope itemtype="http://schema.org/BlogPosting">
	<a href="../17_asyncio.html">
		<h2 itemprop="name headline">18 asyncio</h2>
	</a>
	<time datetime="2017-07-18T23:15:00+02:00" itemprop="datePublished">Tue 18 July 2017</time>
	&nbsp;—&nbsp;
	<span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
		<span itemprop="name">kaka</span>
	</span>
	<div class="summary">
<div class="cell border-box-sizing code_cell rendered">
<div class="input"></div>
	Category:
	<span itemprop="articleSection">
		<a href="../category/fluent_python.html" rel="category">fluent_python</a>
	</span>
	Tags:
 
	<span itemprop="keywords">
		<a href="../tag/asyncio-yield-from.html" rel="tag">asyncio yield from</a>
	</span>
</div>
<hr>
        
<div class="article" itemscope itemtype="http://schema.org/BlogPosting">
	<a href="../17_thread_process.html">
		<h2 itemprop="name headline">17 并行</h2>
	</a>
	<time datetime="2017-07-17T19:05:00+02:00" itemprop="datePublished">Mon 17 July 2017</time>
	&nbsp;—&nbsp;
	<span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
		<span itemprop="name">kaka</span>
	</span>
	<div class="summary">
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>为了高效处理网络 I/O，需要使用并发，因为网络有很高的延时，为了不浪费 CPU 周期去等待，最好在收到网络相应之前做些其他的事</p>
<p>我们首先看依次从网络下载的代码：</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input"></div>
	Category:
	<span itemprop="articleSection">
		<a href="../category/fluent_python.html" rel="category">fluent_python</a>
	</span>
	Tags:
 
	<span itemprop="keywords">
		<a href="../tag/thread-process.html" rel="tag">thread process</a>
	</span>
</div>
<hr>
        
<div class="article" itemscope itemtype="http://schema.org/BlogPosting">
	<a href="../16_coroutine.html">
		<h2 itemprop="name headline">16 协程</h2>
	</a>
	<time datetime="2017-07-14T23:25:00+02:00" itemprop="datePublished">Fri 14 July 2017</time>
	&nbsp;—&nbsp;
	<span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
		<span itemprop="name">kaka</span>
	</span>
	<div class="summary">
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>字典中 to yield 表示产出和让步，对于 Python 生成器中的 yield 来说，这是成立的，yield item 这行代码会产生一个值，提供给 next(...) 调用方，此外，还会做出让步，暂停执行生成器，让调用方继续工作，直到需要使用另一个值再调用 next()。调用方会从生成器中拉取值</p>
<p>语法上来说，协程和生成器类似，都是定义体中包含 yield 关键字的函数，可是，在协程中，yield 通常出现在表达式的右边，可以产出值，也可以不产出 -- 如果 yield 关键字后面没有表达式，那么生成器产出 None，协程可能会从调用方接收数据，不过调用方把数据提供给协程使用的是 <code>.send(datum)</code> 方法，而不是 next(...) 函数。通常调用方会把值推送给协程</p>
<p>yield 关键字甚至还可以不接收或传出数据，不过数据如何流动，yield 都是一种流程控制工具，使用它可以实现协作式多任务：协程可以把控制器让步给中心调度程序，从而激活其他的协程</p>
<p>从根本上把 yield 视作控制流程的方式，这样就好理解协程了</p>
<p>本书前面介绍生成器函数作用不大，但是进行一系列功能改进后，得到了 Python 协程。了解 Python 协程有助于理解各个阶段的改进的功能和复杂度</p>
<p>本章覆盖以下话题：</p>
<ul>
<li>生成器作为协程使用时的行为和状态</li>
<li>使用装饰器自动预激协程</li>
<li>调用方如何使用生成器对象的 .close() 和 .throw(...) 方法控制协程</li>
<li>协程终止时如何返回值</li>
<li>yield from 新语法的用途和语义</li>
<li>使用案例 -- 使用协程管理仿真系统中的并发活动</li>
</ul>
<h2 id="生成器如何进化成协程">生成器如何进化成协程<a class="anchor-link" href="#生成器如何进化成协程">¶</a></h2><p>在 Python 2.5 中实现了 yield 关键字可以在表达式中使用，并在生成器 API 中增加了 .send(value) 方法。生成器的调用可以使用 .send(...) 方法发送数据，发送的数据会称为生成器函数中 yield 表达式的值，因此生成器可以作为协程使用，协程指的是一个过程，这个过程与调用方协作，产出由调用方提供的值</p></div>
	Category:
	<span itemprop="articleSection">
		<a href="../category/fluent_python.html" rel="category">fluent_python</a>
	</span>
	Tags:
 
	<span itemprop="keywords">
		<a href="../tag/coroutine-yield.html" rel="tag">coroutine yield</a>
	</span>
</div>
<hr>
        
<div class="article" itemscope itemtype="http://schema.org/BlogPosting">
	<a href="../15_with.html">
		<h2 itemprop="name headline">15 with 和 else 语句</h2>
	</a>
	<time datetime="2017-07-11T22:35:00+02:00" itemprop="datePublished">Tue 11 July 2017</time>
	&nbsp;—&nbsp;
	<span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
		<span itemprop="name">kaka</span>
	</span>
	<div class="summary">
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>本章讨论其他语言不常见的流程控制，用户可能会忽略这些特性：</p>
<ul>
<li>with 语句和上下文管理器</li>
<li>for while 和 try 语句的 else 子句</li>
</ul>
<p>with 语句会设置一个临时的上下文，交给上下文管理器对象控制，并负责清理上下文。这么做能避免错误并减少样板代码，因此 API 更安全，更易于使用。除了自动关闭文件之外，with 块还有很多用途</p>
<p>else 子句和 with 没关系，不过这两个都内容比较短，所以放到了一个逻辑</p>
<h2 id="先做这个，再做那个：-if-之外的-else-块">先做这个，再做那个： if 之外的 else 块<a class="anchor-link" href="#先做这个，再做那个：-if-之外的-else-块">¶</a></h2><p>else 子句不仅能在 if 语句中使用，还能在 for，while，try 语句中使用</p>
<p>else 子句行为如下：</p>
<p>for: 仅当 for 循环运行完毕时（即 for 循环没有被 break 语句终止）才运行 else</p>
<p>try: 仅当 try 块中没有异常时候才运行 else 块，else 子句抛出的异常不会由前面的 except 子句处理</p>
<p>在所有情况下，如果异常或者 return, break 或 continue 语句导致控制权跳到了复合语句之外，else 也会被跳过</p>
<p>for 循环用 else 如下：</p></div>
	Category:
	<span itemprop="articleSection">
		<a href="../category/fluent_python.html" rel="category">fluent_python</a>
	</span>
	Tags:
 
	<span itemprop="keywords">
		<a href="../tag/else-with.html" rel="tag">else with</a>
	</span>
</div>
<hr>
        
<div class="article" itemscope itemtype="http://schema.org/BlogPosting">
	<a href="../14_iter.html">
		<h2 itemprop="name headline">14 可迭代对象，迭代器和生成器</h2>
	</a>
	<time datetime="2017-07-10T22:35:00+02:00" itemprop="datePublished">Mon 10 July 2017</time>
	&nbsp;—&nbsp;
	<span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
		<span itemprop="name">kaka</span>
	</span>
	<div class="summary">
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>所有生成器都是迭代器，因为生成器完全实现了迭代器接口，不过迭代器一般用于从集合取出元素，生成器用于 “凭空” 创造元素。斐波那契数列例子可以很好的说明两者区别：斐波那契数列中的数有无穷个，在一个集合里放不下。</p>
<p>在 Python 3 中，生成器有广泛用途。现在即使是内置的 range() 函数也要返回一个类似生成器的对象，而以前返回完整列表。如果一定让 range() 函数返回列表，必须明确指明（例如，list(range(100))）。</p>
<p>在 Python 中，所有集合都能迭代。在 Python 内部，迭代器用于支持：</p>
<ul>
<li>for 循环</li>
<li>构建和扩展集合类型</li>
<li>逐行遍历文本文件</li>
<li>列表推导，字典推导和集合推导</li>
<li>元组拆包</li>
<li>调用函数时，使用 <code>*</code> 拆包</li>
</ul>
<p>本章探讨以下话题：</p>
<ul>
<li>语言内部使用 iter(...) 内置函数处理可迭代对象的方式</li>
<li>如何使用 Python 经典的迭代器模式</li>
<li>详细说明生成器函数的工作原理</li>
<li>如何使用生成器函数或生成器表达式代替经典的迭代器</li>
<li>如何使用标准库中通用的生成器函数</li>
<li>如何使用 yield from 语句合并生成器</li>
<li>案例分析： 在一个数据库转换工具中使用生成器处理大型数据集</li>
<li>为什么生成器和协程看似相同，其实差别很大，不能混淆</li>
</ul>
<h2 id="Sentence-类第-1-版：单词序列">Sentence 类第 1 版：单词序列<a class="anchor-link" href="#Sentence-类第-1-版：单词序列">¶</a></h2><p>我们创建一个类，并向它传入一些包含文本的字符串，然后可以逐个单词迭代，第 1 版要实现序列协议，这个类的对象可以迭代，因为所有序列都可以迭代 -- 这一点前面已经说过，现在说明真正的原因</p>
<p>下面展示了一个可以通过索引从文本提取单词的类：</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input"></div>
	Category:
	<span itemprop="articleSection">
		<a href="../category/fluent_python.html" rel="category">fluent_python</a>
	</span>
	Tags:
 
	<span itemprop="keywords">
		<a href="../tag/bytes-iter.html" rel="tag">bytes iter</a>
	</span>
</div>
<hr>
        
<div class="article" itemscope itemtype="http://schema.org/BlogPosting">
	<a href="../13_operator.html">
		<h2 itemprop="name headline">13 运算符重载</h2>
	</a>
	<time datetime="2017-06-23T01:09:00+02:00" itemprop="datePublished">Fri 23 June 2017</time>
	&nbsp;—&nbsp;
	<span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
		<span itemprop="name">kaka</span>
	</span>
	<div class="summary">
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>我们本章会讨论：</p>
<ul>
<li>Python 如何处理终追运算符中不同类型的操作数</li>
<li>使用鸭子类型或显式类型检查处理不同类型的操作数</li>
<li>中缀运算符如何表明自己无法处理的操作数</li>
<li>众多比较运算符（如 ==，>，<= 等等）的特殊行为</li>
<li>增量赋值运算符（如 += ）的默认处理方式和重载方式</li>
</ul>
<h2 id="运算符重载基础">运算符重载基础<a class="anchor-link" href="#运算符重载基础">¶</a></h2><p>在某些圈子里，运算符重载名声不太好，因为总被滥用．Python 加了一些限制，做好了灵活性，可用性和安全性的平衡</p>
<ul>
<li>不能重载内置运算符</li>
<li>不能新建运算符，只能重载现有的</li>
<li>某些运算符不能重载 -- is，and，or 和 not（不过位运算 &，| 和 ~ 可以）</li>
</ul>
<h2 id="一元运算符">一元运算符<a class="anchor-link" href="#一元运算符">¶</a></h2><p><code>- (__neg__)</code> 一元取负运算符，如果 x 是 -2， -x == 2</p>
<p><code>+　(__pos__)</code>　一元取正运算符，通常 x == +x，但也有一些例外</p>
<p><code>~ (__invert__)</code>　对整数按位去饭，定义　~x == -(x + 1)，如果 x 是 2, ~x == -3</p>
<p>支持一元操作符只需要实现相应的特殊方法，这些方法只有一个 self 参数，然后使用符合所在类的逻辑实现。不过，要遵守运算符的一个基本规则：始终返回一个新对象。也就是不能修改 self</p>
<p>对于 <code>-</code> 和 <code>+</code> 来说，结果可能是与 self 属于同一类的实例，多数的时候， + 最好返回 self 的副本。abs(...) 的结果应该是一个标量，但是对于 ～ 来说，很难说明什么结果是合理的，因为可能处理的不是整数，例如 ORM 中，SQL WHERE 子句应该返回反集</p></div>
	Category:
	<span itemprop="articleSection">
		<a href="../category/fluent_python.html" rel="category">fluent_python</a>
	</span>
	Tags:
 
	<span itemprop="keywords">
		<a href="../tag/bytes-operator.html" rel="tag">bytes operator</a>
	</span>
</div>
<hr>
        
<div class="article" itemscope itemtype="http://schema.org/BlogPosting">
	<a href="../12_inherit.html">
		<h2 itemprop="name headline">12 继承的优缺点</h2>
	</a>
	<time datetime="2017-06-19T22:22:00+02:00" itemprop="datePublished">Mon 19 June 2017</time>
	&nbsp;—&nbsp;
	<span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
		<span itemprop="name">kaka</span>
	</span>
	<div class="summary">
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>本章将讨论继承和子类化，重点是说明对 Python 而言尤为重要的两个细节：</p>
<ul>
<li>子类化内置类型的缺点</li>
<li>多重继承的方法和解析顺序</li>
</ul>
<p>我们将通过两个重要的 Python 项目探讨多重继承，这两个项目是 GUI 工具包 Tkinter 和 Web 框架 Django</p>
<p>我们将首先分析子类化内置类型的问题，然后讨论多重继承，通过案例讨论类层次结构方面好的做法和不好的</p>
<h2 id="子类化内置类型很麻烦">子类化内置类型很麻烦<a class="anchor-link" href="#子类化内置类型很麻烦">¶</a></h2><p>在 Python 2.2 之前内置类型（如 list 和 dict）不能子类化，之后可以了，但是有个重要事项：内置类型（使用 C 语言编写）不会调用用户定义的类覆盖的特殊方法</p>
<p>至于内置类型的子类覆盖的方法会不会隐式调用，CPython 没有官方规定，基本上，内置类型的方法不会调用子类覆盖的方法。例如，dict 的子类覆盖 <code>__getitem__()</code> 方法不会被内置类型的 get() 方法调用，下面说明了这个问题：</p>
<p>内置类型的 dict 的 <code>__init__</code> 和 <code>__update__</code> 方法会忽略我们覆盖的 <code>__setitem__</code> 方法</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input"></div>
	Category:
	<span itemprop="articleSection">
		<a href="../category/fluent_python.html" rel="category">fluent_python</a>
	</span>
	Tags:
 
	<span itemprop="keywords">
		<a href="../tag/inherit.html" rel="tag">inherit</a>
	</span>
</div>
<hr>
        
<div class="article" itemscope itemtype="http://schema.org/BlogPosting">
	<a href="../11_abstrack_class.html">
		<h2 itemprop="name headline">11 接口：从协议到抽象基类</h2>
	</a>
	<time datetime="2017-06-17T02:22:00+02:00" itemprop="datePublished">Sat 17 June 2017</time>
	&nbsp;—&nbsp;
	<span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
		<span itemprop="name">kaka</span>
	</span>
	<div class="summary">
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>本章讨论的话题是接口，从鸭子类型代表特征动态协议，到使接口更明确，能验证是否符合规定的抽象基类（Abstract Base Class，ABC）</p>
<p>在 Python 中 上章所说的鸭子类型是接口的常规方式，新只是是抽象基类和类型检查。Python 语言诞生 15 年之后，Python 2.6 才引入抽象基类。</p>
<p>本章先说明 Python 社区以往对接口的不严谨理解：部分实现接口通常被认为是可接受的。我们通过几个示例强调鸭子类型的动态本性，从而澄清这一点</p>
<p>接着，通过 Alex Martelili 写的一篇短文，对抽象基类作介绍，还为 Python 编程下一个新趋势下定义。本章余下的内容专门讲解抽象基类。首先，本章说明抽象基类的常见用途：实现接口时作为超类使用。</p>
<p>然后，说明抽象基类如何检查具体子类是否符合接口定义，以及如何使用注册机制声明一个类实现了某个接口，而不进行子类化操作。最后，说明如何让抽象基类自动 ”识别“ 任何符合接口的类 -- 不进行子类化或注册</p>
<p>我们将实现一个新抽象基类，看看它的运作方式。但是，作者和 Alex Martelli 都不建议你自己编写抽象基类，因为容易过度设计</p>
<blockquote><p>抽象基类与描述符和元类一样，是用于构建框架的工具。因此，只有少数 Python 开发者编写的抽象基类不会对用户施加不必要的限制，让他们做无用功</p>
</blockquote>
<p>下面从 Python 风格探索接口</p>
<h2 id="Python-文化中的接口和协议">Python 文化中的接口和协议<a class="anchor-link" href="#Python-文化中的接口和协议">¶</a></h2><p>在引入抽象基类之前，Python 已经非常成功了，即使现在也很少有代码使用抽象基类。在第一章就讨论了鸭子类型和协议，在上一章，我们将协议定义为非正式的接口，是让 Python 这种动态类型语言实现多态的方式。</p>
<p>接口在动态类型语言是怎么运作的呢？首先，基本的事实是，Python 语言没有 interface 关键字，而且除了抽象基类，每个类都有接口：类实现或继承的公开属性（方法或数据的属性），包括特殊方法，如 <code>__getitem__</code> 或 <code>__add__</code></p>
<p>按照定义，受保护的属性和私有属性不在接口中：即便有“受保护”属性也只是采用命名约定实现的（单个前导下划线）私有属性也可以轻松的访问（第 9 章），原因也是如此，不要违背这些约定</p>
<p>另一方面，不要觉得把公开数据属性放入对象接口中不妥，因为如果需要，总能实现读值方法和设值方法，把数据属性变成特性，使用 obj.attr 语法的客户代码不会受到影响。Vector2d 类就是这么做的</p>
<p>下面的例子 x，y 是公开属性</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input"></div>
	Category:
	<span itemprop="articleSection">
		<a href="../category/fluent_python.html" rel="category">fluent_python</a>
	</span>
	Tags:
 
	<span itemprop="keywords">
		<a href="../tag/abstract.html" rel="tag">abstract</a>
	</span>
</div>
<hr>
 <div class="pagination">
<ul>
    <li class="prev disabled"><a href="#">&larr; Previous</a></li>

    <li class="active"><a href="../author/kaka.html">1</a></li>
    <li class=""><a href="../author/kaka2.html">2</a></li>
    <li class=""><a href="../author/kaka3.html">3</a></li>

    <li class="next"><a href="../author/kaka2.html">Next &rarr;</a></li>

</ul>
</div> 		</div>
	</div> 	<!-- <hr> -->
</div> <!-- /container -->
<footer class="aw-footer bg-danger">
	<div class="container"> <!-- footer -->
		<div class="row">
			<div class="col-md-10 col-md-offset-1">
				<div class="row">
					<div class="col-md-3">
						<h4>Navigation</h4>
						<ul class="list-unstyled my-list-style">
							<li><a href="..">Kaka Blog</a></li>
							<li><a href="http://ghvn7777.github.io/feeds/all.atom.xml" type="application/atom+xml"><i class="fa fa-rss "></i> atom</a></li>
						</ul>
					</div>
					<div class="col-md-3">
						<h4>Author</h4>
						<ul class="list-unstyled my-list-style">
							<li><a href="#">You can add links in your config file</a></li>
							<li><a href="#">Another social link</a></li>
						</ul>
					</div>
					<div class="col-md-3">
						<h4>Categories</h4>
						<ul class="list-unstyled my-list-style">
							<li><a href="../category/feature_engineering.html">feature_engineering (1)</a></li>
							<li><a href="../category/fluent_python.html">fluent_python (22)</a></li>
						</ul>
					</div>
					<div class="col-md-3">
						<h4>Links</h4>
						<ul class="list-unstyled my-list-style">
							<li><a href="http://getpelican.com/">Pelican</a></li>
							<li><a href="http://python.org/">Python.org</a></li>
							<li><a href="http://jinja.pocoo.org/">Jinja2</a></li>
							<li><a href="#">You can modify those links in your config file</a></li>
						</ul>
					</div>
				</div>
			</div>
		</div>
	</div>
</footer>
<div class="container">
	<div class="row">
		<div class="col-md-12 text-center center-block aw-bottom">
			<p>&copy; kaka 2016</p>
			<p>Powered by Pelican</p>
		</div>
	</div>
</div>
<!-- JavaScript -->
<script src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
<script type="text/javascript">
jQuery(document).ready(function($) {
	$("div.collapseheader").click(function () {
		$header = $(this).children("span").first();
		$codearea = $(this).children(".input_area");
		$codearea.slideToggle(500, function () {
			$header.text(function () {
				return $codearea.is(":visible") ? "Collapse Code" : "Expand Code";
			});
		});
	});
});
</script>
</body>
</html>